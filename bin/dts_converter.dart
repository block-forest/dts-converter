import 'dart:io';
import 'package:args/args.dart';
import 'package:path/path.dart';

const String DEFAULT_TARGET_LIBRARY = "";
const String DEFAULT_SOURCE_LIBRARY = "";
const String DEFAULT_SOURCE_DIR = "";
const String DEFAULT_TARGET_DIR = "lib";
const bool FULL_DART_PROJECT = false;

String dart_library_name;
String source_library_name;
String source_basedir;
String target_basedir;
bool create_full_project;

String library_file_content;
String dart_file_content;

void main(List args) {
  _setupArgs(args);

  if (source_basedir == DEFAULT_SOURCE_DIR) {
    print("Well, at least provide the --source dir, will you?");
    exit(1);
  }

  if (target_basedir == new File(target_basedir).absolute.path) {
    print(
        "Please provide a --target path relative to your working directory (the directory you're running this script from).");
    exit(1);
  }

  if (source_library_name == DEFAULT_SOURCE_LIBRARY) {
    print(
        "Please provide a --source-library name equivalent to what you find under 'declare var' in the d.ts source file, for example 'Chart' or 'THREE'.");
    exit(1);
  }

  if (dart_library_name == DEFAULT_TARGET_LIBRARY) {
    dart_library_name = source_library_name;
  }

  //prepare the library file so we can append 'part' files
  library_file_content = '''
@JS()
library $dart_library_name;

import "package:func/func.dart";
import "package:js/js.dart";
import 'dart:html';


''';

  //prepare the dart file so we can append the converted things
  if (create_full_project) {
    dart_file_content = '''
part of $dart_library_name;


''';
  } else {
    dart_file_content = library_file_content;
  }

  /* iterate over source path, grab *.ts files */
  Directory sourceDir = new Directory(join(source_basedir));
  if (sourceDir.existsSync()) {
    sourceDir.listSync(recursive: true, followLinks: false).forEach((FileSystemEntity entity) {
      if (FileSystemEntity.typeSync(entity.path) == FileSystemEntityType.FILE &&
          extension(entity.path).toLowerCase() == ".ts") {
        _convert(entity.path);
      }
    });
    if (create_full_project) {
      _writeTemplates();
    } else {
      _addLibraryToRootPubspec();
    }
  } else {
    print("The directory that was provided as source_basedir does not exist: $source_basedir");
    exit(1);
  }
}

/// Writes pubspec.yaml and package.dart into the newly created package.
void _writeTemplates() {
  //create library file
  new File(join(target_basedir, "lib", "$dart_library_name.dart")).absolute
    ..createSync(recursive: true)
    ..writeAsStringSync(library_file_content);

  //create pubspec .yaml file
  String pubspecFileContent = '''
name: $dart_library_name
version: 0.1.0
description: autogenerated dart js interop type definition for $source_library_name
dependencies:
  logging: any
  func: ^0.1.0
  js: ^0.6.0
  args: any
  path: any
''';

  new File(join(target_basedir, "pubspec.yaml")).absolute
    ..createSync(recursive: true)
    ..writeAsStringSync(pubspecFileContent);
}

/// Adds the newly created package as dependency to the project's root pubspec.yaml.
void _addLibraryToRootPubspec() {
  String insertionString = '''
dependencies:
  $dart_library_name:
    path: ${join(target_basedir, dart_library_name)}''';

  File pubspecRootFile = new File('pubspec.yaml').absolute;
  String pubspecRootFileContent = pubspecRootFile.readAsStringSync();
  if (!pubspecRootFileContent.contains(dart_library_name)) {
    pubspecRootFileContent = pubspecRootFileContent.split(new RegExp("dependencies\\s*:")).join(insertionString);
    pubspecRootFile.writeAsStringSync(pubspecRootFileContent, mode: FileMode.WRITE);
  }
}

/// Takes a File path, e.g. test/chart/chart.d.ts, and writes it to
/// the output directory provided, e.g. lib/src/chart.d.dart.
/// During the process, excessive RegExp magic is applied.
void _convert(String asFilePath) {
  //e.g. test/chart/chart.d.ts
  print("asFilePath: $asFilePath");

  File asFile = new File(asFilePath);

  //Package name, e.g. chart/foo
  String dartFilePath = asFilePath.replaceFirst(new RegExp(source_basedir + "/"), "");
  dartFilePath = dirname(dartFilePath);
  print("dartFilePath: $dartFilePath");

  //New filename, e.g. chart.d.dart
  String dartFileName = basenameWithoutExtension(asFile.path)
      .replaceAllMapped(new RegExp("(IO|I|[^A-Z-])([A-Z])"), (Match m) => (m.group(1) + "_" + m.group(2)))
      .toLowerCase();
  dartFileName += ".dart";
  print("dartFileName: $dartFileName");

  String asFileContents = asFile.readAsStringSync();
  String dartFileContents = _applyMagic(asFileContents);

  //Write new file
  String dartFileNameFull = join(target_basedir, create_full_project ? "lib" : "", create_full_project ? "src" : "",
      dart_library_name.toLowerCase(), dartFileName);
  print("dartFileNameFull: $dartFileNameFull");
  new File(dartFileNameFull).absolute
    ..createSync(recursive: true)
    ..writeAsStringSync(dartFileContents);

  library_file_content += "\npart 'src/${dart_library_name.toLowerCase()}/$dartFileName';";

  // format code in Dart style
  if (Platform.isWindows) {
    Process.runSync("dartfmt.bat", ['-w', dartFileNameFull]);
  } else {
    Process.runSync("dartfmt", ['-w', dartFileNameFull]);
  }
}

/// Applies magic to an .d.ts file String, converting it to almost error free Dart.
/// Please report errors and edge cases to github issue tracker.
String _applyMagic(String f) {
  // Remove Namespace if exists
  if (f.contains("declare namespace")) {
    f = f.replaceAllMapped(new RegExp("(\\s*)declare\\s+namespace\\s+[A-Za-z0-9.]+\\s*\\{"), (Match m) => "${m[1]}");
    // remove closing bracket at end of file
    f = f.replaceAll(new RegExp("\\}\\s*\$"), "");
  }

  /* --------- TYPES */

  f = f.replaceAll(new RegExp("number"), "num");
  f = f.replaceAll(new RegExp("boolean"), "bool");
  f = f.replaceAll(new RegExp("string"), "String");
  f = f.replaceAll(new RegExp("Array<"), "List<");
  f = f.replaceAll(new RegExp("\\{\\}\\[\\]"), "List");

  /* --------- DEFINITION BODY */

  /*
    Search for 'interface' + CLASS + 'extends FOO' + BODY
    Repace with annotated 'external CLASS' and constructor definition
    Comment out 'extends FOO' if exists
    Insert BODY into both factory constructor and class body for later type conversion
   */
  f = f.replaceAllMapped(
      new RegExp("(\\s*)interface\\s+([A-Za-z0-9.]+)\\s+(extends\\s+\\w+)*\\s*\\{([^}]+)\\}\n"),
      (Match m) =>
          "${m[1]}\n@anonymous\n@JS()\nclass ${m[2]} {\n\texternal factory ${m[2]} ${m[3] == null ? "" : "/* ${m[3]} */"}(\n\t\t{${m[4]}});\n${m[4]}\n}\n");

  /* --------- DEFINITION SYNTAX */

  // Remove "?"
  f = f.replaceAllMapped(new RegExp("(\\?)"), (Match m) => "");

  // Convert function definitions
  // f.ex. foo : () => any  -->  any foo()
  // f.ex. foo : (value : number) => string --> string foo(value : number)
  f = f.replaceAllMapped(new RegExp("\\?*:\\s*\\(([^)]*)\\s*\\)\\s*=>"), (Match m) => "(${m[1]}) :");

  // Convert type definition position
  // f.ex. foo : number --> number foo
  f = f.replaceAllMapped(new RegExp("(\\s*)(.*)\\s*:\\s*(.*)\\s*;"), (Match m) => "${m[1]} ${m[3]} ${m[2]};");

  // Convert type definition position in function parameter definition
  // f.ex. foo(bar : number) --> foo(number bar)
  f = f.replaceAllMapped(
      new RegExp("([A-Za-z0-9_]+)\\s*:\\s*([A-Za-z0-9_\\[\\]]*)\\s*([),])"), (Match m) => "${m[2]} ${m[1]} ${m[3]}");

  // Convert typed array to typed List
  // f.ex. number[] --> List<number>
  f = f.replaceAllMapped(new RegExp("([A-Za-z0-9_]+)\\[\\]"), (Match m) => "List<${m[1]}>");

  /* --------- FIELDS */

  // Fields to factory named arguments
  f = f.replaceAllMapped(new RegExp("\\(\\s*\\{([^}]*)\\}\\s*\\);"), (Match m) {
    //replace any with Function
    String intrnl = m[1].replaceAll(new RegExp("any"), "Func0<dynamic>");
    //remove "()" if Function is the type
    intrnl = intrnl.replaceAllMapped(
        new RegExp("(Func[A-Za-z0-9_<>]+)\\s+(.*)\\s*\\(\\s*\\)"), (Match n) => "${n[1]} ${n[2]}");
    //replace ; with ,
    intrnl = intrnl.replaceAll(new RegExp(";"), ",");
    // remove erraneously inserted arguments (function definitions)
    intrnl = intrnl.replaceAll(new RegExp("\\s*.+\\(.*\\)\\s*,"), "");
    // remove comma at end of parameter list
    intrnl = intrnl.replaceAll(new RegExp(",\\s*\$"), "\n");

    return "(\n\t{${intrnl}\t});";
  });

  // Fields to class getters/setters
  f = f.replaceAllMapped(new RegExp("\\}\\s*\\)\\s*;\\s*([^}]+)\\}"), (Match m) {
    // prefix all members that are not functions with 'external' and add 'get'
    String intrnl = m[1].replaceAllMapped(
        new RegExp("([A-Za-z0-9_<>]+)\\s*([A-Za-z0-9_<>]+)\\s*;"), (Match n) => "external ${n[1]} get ${n[2]};");
    intrnl =
        intrnl.replaceAllMapped(new RegExp("any(.*)\\(\\s*\\)"), (Match n) => "external Func0<dynamic> get ${n[1]}");

    //prefix all functions with 'external'
    intrnl = intrnl.replaceAllMapped(
        new RegExp("([A-Za-z0-9_<>]+\\s+[A-Za-z0-9_<>]+\\(.*\\))\\s*;"), (Match n) => "external ${n[1]};");

    //create setters
    intrnl = intrnl.replaceAllMapped(new RegExp("external\\s+([A-Za-z0-9_<>]+)\\s+get\\s+([A-Za-z0-9_]+)\\s*;"),
        (Match n) => "external ${n[1]} get ${n[2]};\n\t\texternal set ${n[2]}(${n[1]} v);");

    return "});\n\n\t\t${intrnl}\n}";
  });

  /* --------- CLEANUP */

  // Delete factory if no arguments
  f = f.replaceAll(
      new RegExp("external\\s*factory\\s*[A-Za-z0-9_]+\\s*[A-Za-z0-9_\\/\\* ]*\\s*\\(\\s*\\{\\s*\\}\\);"), "");

  /* --------- TRICKY STUFF */

  /**
   * search for interface and var def that are named like the library (e.g. Chart)
    EXAMPLE:
      declare var Chart: {
     Chart new (CanvasRenderingContext2D context );
      defaults: {
         ChartSettings global;
      }
    };
   * */
  String declaredClasses = "";

  RegExp r1 = new RegExp("class ($source_library_name)", caseSensitive: false);
  RegExp r2 = new RegExp("declare var $source_library_name", caseSensitive: false);
  RegExp r3 = new RegExp("$source_library_name\\s+new\\s+\\((.*)\\)\\s*;", caseSensitive: false);
  if (r1.hasMatch(f) && r2.hasMatch(f)) {
    String insert = "";
    String content = "";

    //library name
    String lib_name = r1.firstMatch(f).group(1);

    // extract conversion of 'LIB new (...)' to 'external LIB (...)'
    content = r3.firstMatch(f).group(1);
    insert = "external $lib_name($content);";

    f = f.replaceAllMapped(r3, (Match m) => "");

    // extract everything inside LIB var declaration
    Match match = new RegExp("(declare\\s+var\\s+${lib_name}\\s*\\:\\s*\\{)([^\\}]*\\s*\\}\\s*\\};)").firstMatch(f);
    content = match.group(2);
    f = f.replaceFirst(match.group(1) + match.group(2), "");

    // convert properties of LIB var declaration
    content.replaceAllMapped(new RegExp("([A-Za-z0-9_]+)\\s*:\\s*\\{([^\\}]*)\\}"), (Match m) {
      // convert each property to LIB class getter/setter as own classes
      insert += "\nexternal static ${lib_name}_${m[1]} get ${m[1]};";
      insert += "\nexternal static set ${m[1]}(${lib_name}_${m[1]} v);";
      // convert each property body to own class
      declaredClasses += "\n@anonymous\n@JS()\nclass ${lib_name}_${m[1]}{\n${m[2]}\n}\n";
      declaredClasses = declaredClasses.replaceAllMapped(
          new RegExp("([A-Za-z0-9_]+)\\s+([A-Za-z0-9_]+)\\s*;"), (Match n) => "\nexternal ${n[1]} get ${n[2]};");
    });

    f = f.replaceAllMapped(
        new RegExp("@anonymous\\s*(@JS\\(\\)\\s*class\\s+${lib_name}\\s*\\{)"), (Match m) => "${m[1]}\n\t${insert}\n");
  }

  return "${dart_file_content} $f \n\n$declaredClasses";
}

/// Manages the script's arguments and provides instructions and defaults for the --help option.
void _setupArgs(List args) {
  ArgParser argParser = new ArgParser();
  argParser.addOption('target-library',
      defaultsTo: DEFAULT_TARGET_LIBRARY,
      help: 'The name of the library to be generated.',
      valueHelp: 'target-library', callback: (_dlibrary) {
    dart_library_name = _dlibrary;
  });
  argParser.addOption('source-library',
      defaultsTo: DEFAULT_SOURCE_LIBRARY,
      help: 'The name of the javascript library to convert.',
      valueHelp: 'source-library', callback: (_slibrary) {
    source_library_name = _slibrary;
  });
  argParser.addOption('source',
      abbr: 's',
      defaultsTo: DEFAULT_SOURCE_DIR,
      help: 'The path (relative or absolute) to the Typescript .d.ts source file(s) to convert.',
      valueHelp: 'source', callback: (_source_basedir) {
    source_basedir = _source_basedir;
  });
  argParser.addOption('target',
      abbr: 't',
      defaultsTo: DEFAULT_TARGET_DIR,
      help:
          'The path (relative!) the generated Dart library will be written to. Usually, your Dart project\'s \'lib\' directory.',
      valueHelp: 'target', callback: (_target_basedir) {
    target_basedir = _target_basedir;
  });
  argParser.addFlag('create-project',
      abbr: 'c',
      negatable: false,
      defaultsTo: FULL_DART_PROJECT,
      help: 'Create full dart project with pubspec and library file.', callback: (_flibrary) {
    create_full_project = _flibrary;
  });

  argParser.addFlag('help', negatable: false, help: 'Displays the help.', callback: (help) {
    if (help) {
      print(argParser.usage);
      exit(1);
    }
  });

  argParser.parse(args);
}
